diff --git a/hil/src/commands/button_ctrl.rs b/hil/src/commands/button_ctrl.rs
index 7845481..1f762cf 100644
--- a/hil/src/commands/button_ctrl.rs
+++ b/hil/src/commands/button_ctrl.rs
@@ -4,7 +4,7 @@ use humantime::parse_duration;
 use std::time::Duration;
 use tracing::info;

-use crate::pin_controller::PinCtrl;
+use crate::commands::PinCtrl;

 #[derive(Debug, Parser)]
 pub struct ButtonCtrl {
@@ -30,6 +30,8 @@ impl ButtonCtrl {

             controller.press_power_button(Some(self.press_duration))?;

+            controller.destroy().wrap_err("failed to destroy ftdi")?;
+
             Ok(())
         })
         .await
diff --git a/hil/src/commands/mod.rs b/hil/src/commands/mod.rs
index 7ae1c22..fcbc473 100644
--- a/hil/src/commands/mod.rs
+++ b/hil/src/commands/mod.rs
@@ -19,3 +19,53 @@ pub use self::nfsboot::Nfsboot;
 pub use self::ota::Ota;
 pub use self::reboot::Reboot;
 pub use self::set_recovery_pin::SetRecoveryPin;
+
+use clap::Args;
+use color_eyre::{eyre::bail, Result};
+
+use crate::ftdi::{FtdiGpio, FtdiId};
+use crate::pin_controller::PinController;
+
+/// Parameters for creating a pin controller.
+#[derive(Debug, Clone, Args)]
+pub struct PinCtrl {
+    /// Type of pin controller to use (ftdi, relay, mock)
+    #[arg(long, default_value = "ftdi", value_name = "TYPE")]
+    pub pin_ctrl_type: String,
+
+    /// FTDI device serial number
+    #[arg(long)]
+    pub ftdi_serial_number: Option<String>,
+
+    /// FTDI device description
+    #[arg(long)]
+    pub ftdi_description: Option<String>,
+}
+
+impl PinCtrl {
+    pub fn build_controller(self) -> Result<Box<dyn PinController + Send>> {
+        match self.pin_ctrl_type.as_str() {
+            "ftdi" => {
+                let builder = FtdiGpio::builder();
+                let configured = match (self.ftdi_serial_number, self.ftdi_description) {
+                    (Some(serial), _) => builder.with_id(FtdiId::SerialNumber(serial))?,
+                    (None, Some(desc)) => builder.with_id(FtdiId::Description(desc))?,
+                    (None, None) => builder.with_default_device()?,
+                };
+                Ok(Box::new(configured.configure()?))
+            }
+            "relay" => {
+                bail!("Relay pin controller not yet implemented")
+            }
+            "mock" => {
+                bail!("Mock pin controller not yet implemented")
+            }
+            other => {
+                bail!(
+                    "Unknown pin controller type: '{}'. Supported types: ftdi, relay, mock",
+                    other
+                )
+            }
+        }
+    }
+}
diff --git a/hil/src/commands/ota/mod.rs b/hil/src/commands/ota/mod.rs
index 31a3cc0..20701ad 100644
--- a/hil/src/commands/ota/mod.rs
+++ b/hil/src/commands/ota/mod.rs
@@ -14,7 +14,7 @@ use orb_hil::{AuthMethod, SshConnectArgs, SshWrapper};
 use secrecy::SecretString;
 use tracing::{error, info, instrument};

-use crate::pin_controller::PinCtrl;
+use crate::commands::PinCtrl;

 mod monitor;
 mod reboot;
diff --git a/hil/src/commands/reboot.rs b/hil/src/commands/reboot.rs
index 81c92ea..0195c05 100644
--- a/hil/src/commands/reboot.rs
+++ b/hil/src/commands/reboot.rs
@@ -1,7 +1,7 @@
 use clap::Parser;
 use color_eyre::{eyre::WrapErr as _, Result};

-use crate::pin_controller::PinCtrl;
+use crate::commands::PinCtrl;

 /// Reboot the orb
 #[derive(Debug, Parser)]
diff --git a/hil/src/commands/set_recovery_pin.rs b/hil/src/commands/set_recovery_pin.rs
index 15441ae..fe2c9b8 100644
--- a/hil/src/commands/set_recovery_pin.rs
+++ b/hil/src/commands/set_recovery_pin.rs
@@ -3,7 +3,7 @@ use color_eyre::{eyre::WrapErr as _, Result};
 use std::time::Duration;

 use crate::ftdi::OutputState;
-use crate::pin_controller::PinCtrl;
+use crate::commands::PinCtrl;

 /// Set the recovery pin to a specific state without triggering the button
 ///
diff --git a/hil/src/ftdi.rs b/hil/src/ftdi.rs
index 066bf79..ba9d62e 100644
--- a/hil/src/ftdi.rs
+++ b/hil/src/ftdi.rs
@@ -55,20 +55,6 @@ pub enum FtdiId {
     Description(String),
 }

-/// Parameters for selecting an FTDI device.
-///
-/// Either `serial_num` or `desc` can be specified to select a specific device.
-/// If both are `None`, the default device will be used.
-#[derive(Debug, Clone, Default, Eq, PartialEq, clap::Args)]
-pub struct FtdiParams {
-    /// The serial number of the FTDI device to use
-    #[arg(long, conflicts_with = "desc")]
-    pub serial_num: Option<String>,
-    /// The description of the FTDI device to use
-    #[arg(long, conflicts_with = "serial_num")]
-    pub desc: Option<String>,
-}
-
 /// Type-state builder pattern for creating a [`FtdiGpio`].
 #[derive(Clone, Debug)]
 pub struct Builder<S>(S);
@@ -210,18 +196,11 @@ impl Builder<NeedsDevice> {
         Ok(Builder(NeedsConfiguring { device: ftdi }))
     }

-    /// Opens a device based on the provided parameters.
-    ///
-    /// Selects the appropriate device based on which fields in `params` are set:
-    /// - If `serial_num` is set, opens by serial number
-    /// - If `desc` is set, opens by description
-    /// - If both are None, opens the default device
-    /// - If both are set, prefers `serial_num`
-    pub fn with_params(self, params: FtdiParams) -> Result<Builder<NeedsConfiguring>> {
-        match (params.serial_num, params.desc) {
-            (Some(serial), _) => self.with_serial_number(&serial),
-            (None, Some(desc)) => self.with_description(&desc),
-            (None, None) => self.with_default_device(),
+    /// Opens a device based on the provided [`FtdiId`].
+    pub fn with_id(self, id: FtdiId) -> Result<Builder<NeedsConfiguring>> {
+        match id {
+            FtdiId::SerialNumber(serial) => self.with_serial_number(&serial),
+            FtdiId::Description(desc) => self.with_description(&desc),
         }
     }
 }
@@ -277,7 +256,7 @@ impl FtdiGpio {
     /// let ftdi = FtdiGpio::builder()
     ///     .with_default_device()?
     ///     .configure()?
-    ///
+    ///
     /// ```
     pub fn builder() -> Builder<NeedsDevice> {
         Builder(NeedsDevice)
@@ -289,12 +268,6 @@ impl FtdiGpio {
         write_pins(&mut self.device, self.desired_state)
     }

-    /// Destroys the ftdi device, and fully resets its usb interface. Using this
-    /// instead of Drop allows for explicit handling of errors.
-    pub fn destroy(mut self) -> Result<()> {
-        self.destroy_helper()
-    }
-
     /// # Panics
     /// Panics if there is more than one matching device found. We don't have
     /// the ability to handle this case elegantly so better to just panic.
@@ -437,6 +410,10 @@ impl crate::pin_controller::PinController for FtdiGpio {
     fn turn_on(&mut self) -> Result<()> {
         self.press_power_button(Some(std::time::Duration::from_secs(4)))
     }
+
+    fn destroy(&mut self) -> Result<()> {
+        self.destroy_helper()
+    }
 }

 #[cfg(test)]
diff --git a/hil/src/lib.rs b/hil/src/lib.rs
index 3a984f5..609e27c 100644
--- a/hil/src/lib.rs
+++ b/hil/src/lib.rs
@@ -1,6 +1,5 @@
 #![forbid(unsafe_code)]

-mod ftdi;
 mod pin_controller;
 mod ssh_wrapper;

diff --git a/hil/src/pin_controller.rs b/hil/src/pin_controller.rs
index 841474e..efb6fb2 100644
--- a/hil/src/pin_controller.rs
+++ b/hil/src/pin_controller.rs
@@ -1,53 +1,6 @@
-use clap::Args;
-use color_eyre::{eyre::bail, Result};
-
-// Re-export types from ftdi module for convenience
-pub use crate::ftdi::{FtdiGpio, FtdiParams};
-
-/// Parameters for creating a pin controller.
-#[derive(Debug, Clone, Args)]
-pub struct PinCtrl {
-    /// Type of pin controller to use (ftdi, relay, mock)
-    #[arg(long, default_value = "ftdi", value_name = "TYPE")]
-    pub pin_ctrl_type: String,
-
-    #[command(flatten)]
-    pub ftdi: FtdiParams,
-    // Future: add other controller types here
-    // #[command(flatten)]
-    // pub relay: RelayParams,
-}
-
-impl PinCtrl {
-    /// Build a pin controller from the parameters.
-    ///
-    /// This is a blocking operation that initializes the hardware controller.
-    /// Returns a trait object for runtime polymorphism.
-    pub fn build_controller(self) -> Result<Box<dyn PinController + Send>> {
-        match self.pin_ctrl_type.as_str() {
-            "ftdi" => {
-                let ftdi = FtdiGpio::builder().with_params(self.ftdi)?.configure()?;
-                Ok(Box::new(ftdi))
-            }
-            "relay" => {
-                bail!("Relay pin controller not yet implemented")
-            }
-            "mock" => {
-                bail!("Mock pin controller not yet implemented")
-            }
-            other => {
-                bail!("Unknown pin controller type: '{}'. Supported types: ftdi, relay, mock", other)
-            }
-        }
-    }
-}
+use color_eyre::Result;

 /// Trait for controlling power and recovery pins on hardware devices.
-///
-/// This trait provides a high-level interface for controlling the Orb's
-/// power button and recovery mode pins. Different hardware backends
-/// (FTDI, relay, GPIO sysfs, mock for testing, etc.) can implement this
-/// trait to provide the same functionality.
 pub trait PinController {
     /// Press the power button for the specified duration.
     ///
@@ -65,11 +18,6 @@ pub trait PinController {
     fn set_recovery(&mut self, enabled: bool) -> Result<()>;

     /// Reset the controller hardware state.
-    ///
-    /// This resets the controller to a clean state, typically resetting all
-    /// pins to their default values and reinitializing the hardware interface.
-    /// This is important between power cycles to ensure pins don't remain in
-    /// their previous state.
     fn reset(&mut self) -> Result<()>;

     /// Turn off the device by pressing the power button.
@@ -77,4 +25,7 @@ pub trait PinController {

     /// Turn on the device by pressing the power button.
     fn turn_on(&mut self) -> Result<()>;
+
+    /// Destroy the controller, resetting hardware state.
+    fn destroy(&mut self) -> Result<()>;
 }
