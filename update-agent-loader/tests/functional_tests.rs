use ed25519_dalek::{Signer, SigningKey};
use rand::RngCore;
use std::env;
use std::io::Write;
use std::path::PathBuf;
use tempfile::NamedTempFile;
use tokio::runtime::Runtime;
use wiremock::{
    matchers::{method, path},
    Mock, MockServer, ResponseTemplate,
};

/// Load the test signing key that was generated by build.rs
fn generate_test_signing_keypair() -> SigningKey {
    // Generate a random seed for the key
    let mut seed = [0u8; 32];
    rand::thread_rng().fill_bytes(&mut seed);
    ed25519_dalek::SigningKey::from_bytes(&seed)
}

/// Sign a binary with the specified keypair
/// Returns a new Vec<u8> containing the original binary plus signature data
fn sign_binary(data: &[u8], signing_key: &SigningKey) -> Vec<u8> {
    // Create the signature
    let signature = signing_key.sign(data);
    let sig_bytes = signature.to_bytes();
    let magic_bytes = b"$WLD TO THE MOON";

    // Build the signed binary: original data + signature + signature size + magic bytes
    let mut signed_data =
        Vec::with_capacity(data.len() + sig_bytes.len() + 4 + magic_bytes.len());

    // Add the original binary data
    signed_data.extend_from_slice(data);

    // Add the signature
    signed_data.extend_from_slice(&sig_bytes);

    // Add the signature size (little-endian u32)
    signed_data.extend_from_slice(&(sig_bytes.len() as u32).to_le_bytes());

    // Add the magic bytes
    signed_data.extend_from_slice(magic_bytes);

    signed_data
}

#[test]
fn test_cli_args_parsing() {
    let test_tmpdir = PathBuf::from(env!("CARGO_TARGET_TMPDIR"))
        .join("update-agent-loader-test-cli-args-parsing");
    let result = escargot::CargoBuild::new()
        .bin("update-agent-loader")
        .current_release()
        .current_target()
        .target_dir(test_tmpdir)
        .run()
        .unwrap()
        .command()
        .arg("--help")
        .output()
        .unwrap();

    assert!(result.status.success());
    let stdout = String::from_utf8(result.stdout).expect("stdout is UTF-8 string");
    assert!(stdout.contains("URL to download the executable from"));
    assert!(stdout.contains("Arguments to pass to the downloaded executable"));
}

#[test]
fn test_download_and_execute_http() {
    let test_tmpdir = PathBuf::from(env!("CARGO_TARGET_TMPDIR"))
        .join("update-agent-loader-test-download-and-execute-http");
    // Start a mock HTTP server for testing
    let rt = Runtime::new().unwrap();
    let mock_server = rt.block_on(MockServer::start());

    // Read /bin/echo for our test executable and sign it
    let secret_key = generate_test_signing_keypair();
    let echo_binary = std::fs::read("/bin/echo").expect("Failed to read /bin/echo");
    let signed_binary = sign_binary(&echo_binary, &secret_key);

    // Create the mock endpoint serving the signed binary
    rt.block_on(
        Mock::given(method("GET"))
            .and(path("/binary"))
            .respond_with(ResponseTemplate::new(200).set_body_bytes(signed_binary))
            .mount(&mock_server),
    );

    // Build the URL to our mock server - using plain HTTP for testing
    let url = format!("{}/binary", mock_server.uri());

    let test_string = "test string";

    // Save pubkey in a tempfile to be used en escargot build
    let mut pubkey_temp = NamedTempFile::new().unwrap();
    pubkey_temp
        .write_all(secret_key.verifying_key().as_bytes())
        .unwrap();

    // Build update-agent-loader with HTTP(no-S) and a test pubkey
    let result = escargot::CargoBuild::new()
        .bin("update-agent-loader")
        .current_release()
        .current_target()
        .features("allow_http")
        .env("UPDATE_AGENT_LOADER_PUBLIC_KEY", pubkey_temp.path())
        .target_dir(test_tmpdir)
        .run()
        .unwrap()
        .command()
        .args(["--url", &url, "--", test_string])
        .output()
        .unwrap();

    println!("result {result:?}");
    assert!(result.status.success());
    let stdout = String::from_utf8(result.stdout).expect("stdout is UTF-8 string");
    // check that echo printed the expected output
    assert_eq!(stdout.trim(), test_string);
}
