use ed25519_dalek::{Signer, SigningKey};
use tokio::runtime::Runtime;
use wiremock::{
    matchers::{method, path},
    Mock, MockServer, ResponseTemplate,
};

/// Load the test signing key that was generated by build.rs
fn load_test_signing_key() -> SigningKey {
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
    let secret_key_path = std::path::Path::new(&manifest_dir)
        .join("target")
        .join("debug")
        .join("keys")
        .join("secret_key.bin");

    // Read the key from disk
    let secret_key_bytes = std::fs::read(secret_key_path)
        .expect("Failed to read test secret key. Make sure to run in debug mode.");

    SigningKey::from_bytes(secret_key_bytes.as_slice().try_into().unwrap())
}

/// Sign a binary with the specified keypair
/// Returns a new Vec<u8> containing the original binary plus signature data
fn sign_binary(data: &[u8], signing_key: &SigningKey) -> Vec<u8> {
    // Create the signature
    let signature = signing_key.sign(data);
    let sig_bytes = signature.to_bytes();

    // Build the signed binary: original data + signature + signature size + magic bytes
    let mut signed_data = Vec::with_capacity(
        data.len() + sig_bytes.len() + 4 + b"$WLD TO THE MOON".len(),
    );

    // Add the original binary data
    signed_data.extend_from_slice(data);

    // Add the signature
    signed_data.extend_from_slice(&sig_bytes);

    // Add the signature size (little-endian u32)
    signed_data.extend_from_slice(&(sig_bytes.len() as u32).to_le_bytes());

    // Add the magic bytes
    signed_data.extend_from_slice(b"$WLD TO THE MOON");

    signed_data
}

#[test]
fn test_cli_args_parsing() {
    let result = escargot::CargoBuild::new()
        .bin("update-agent-loader")
        .current_release()
        .current_target()
        .run()
        .unwrap()
        .command()
        .arg("--help")
        .output()
        .unwrap();

    assert!(result.status.success());
    let stdout = String::from_utf8(result.stdout).expect("stdout is UTF-8 string");
    assert!(stdout.contains("URL to download the executable from"));
    assert!(stdout.contains("Arguments to pass to the downloaded executable"));
}

#[test]
fn test_download_and_execute_http() {
    // Start a mock HTTP server for testing
    let rt = Runtime::new().unwrap();
    let mock_server = rt.block_on(MockServer::start());

    // Read /bin/echo for our test executable and sign it
    let signing_key = load_test_signing_key();
    let echo_binary = std::fs::read("/bin/echo").expect("Failed to read /bin/echo");
    let signed_binary = sign_binary(&echo_binary, &signing_key);

    // Create the mock endpoint serving the signed binary
    rt.block_on(
        Mock::given(method("GET"))
            .and(path("/binary"))
            .respond_with(ResponseTemplate::new(200).set_body_bytes(signed_binary))
            .mount(&mock_server),
    );

    // Build the URL to our mock server - using plain HTTP for testing
    let url = format!("{}/binary", mock_server.uri());

    let test_string = "test string";
    // Get the path to the test key for passing to the build
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
    let secret_key_path = std::path::Path::new(&manifest_dir)
        .join("target")
        .join("debug")
        .join("keys")
        .join("secret_key.bin")
        .to_string_lossy()
        .to_string();

    let result = escargot::CargoBuild::new()
        .bin("update-agent-loader")
        .current_release()
        .current_target()
        .features("allow_http")
        .env("TEST_KEY", secret_key_path)
        .run()
        .unwrap()
        .command()
        .args(["--url", &url, "--", test_string])
        .output()
        .unwrap();

    println!("result {:?}", result);
    assert!(result.status.success());
    let stdout = String::from_utf8(result.stdout).expect("stdout is UTF-8 string");
    // check that echo printed the expected output
    assert_eq!(stdout.trim(), test_string);
}
