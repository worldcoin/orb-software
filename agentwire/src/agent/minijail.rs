//! Minijail-based sandboxing for process agents.
//!
//! This module provides configurable seccomp-BPF syscall filtering and optional
//! filesystem isolation via pivot_root for process-based agents.
//!
//! # Security Model
//!
//! The sandbox uses Linux seccomp-BPF to filter syscalls at the kernel level:
//! - **Allowed syscalls**: Execute normally
//! - **Blocked syscalls**: Return specified errno or send SIGSYS signal
//! - **Unlisted syscalls**: Default action (Trap or Kill)
//!
//! Optionally, filesystem isolation can be applied using pivot_root to restrict
//! the process to a minimal filesystem view.
//!
//! # Example
//!
//! ```ignore
//! use agentwire::agent::minijail::{SeccompPolicy, BlockAction, DefaultAction};
//!
//! let policy = SeccompPolicy {
//!     allowed_syscalls: vec![
//!         "read", "write", "openat", "close", "mmap", "munmap",
//!         // ... add syscalls your agent needs
//!     ].into_iter().map(String::from).collect(),
//!     blocked_syscalls: vec![
//!         ("socket".into(), BlockAction::ReturnErrno(libc::EPERM)),
//!         ("connect".into(), BlockAction::ReturnErrno(libc::EPERM)),
//!         ("bind".into(), BlockAction::ReturnErrno(libc::EPERM)),
//!     ],
//!     default_action: DefaultAction::Trap,
//! };
//! ```

use std::{
    io::{self, Write},
    path::PathBuf,
};

use minijail::Minijail;

/// Action to take when a blocked syscall is invoked.
#[derive(Clone, Debug)]
pub enum BlockAction {
    /// Return specified errno (e.g., `libc::EPERM`) - allows graceful handling.
    /// Libraries can check the error and handle it appropriately.
    ReturnErrno(i32),
    /// Send SIGSYS signal - can be caught by a signal handler for debugging.
    /// If no handler is installed, the process is terminated.
    Trap,
    /// Immediately terminate the process - maximum security, no debugging.
    Kill,
}

/// Default action for syscalls not explicitly listed in allowed or blocked lists.
#[derive(Clone, Debug, Default)]
pub enum DefaultAction {
    /// Send SIGSYS signal (default) - debuggable, still secure.
    /// The process can install a signal handler to log violations before terminating.
    #[default]
    Trap,
    /// Immediately terminate the process - maximum security, no debugging.
    Kill,
}

/// Configuration for seccomp-BPF syscall filtering.
///
/// The seccomp policy defines which syscalls are allowed, which are blocked
/// (with specific actions), and what happens for unlisted syscalls.
#[derive(Clone, Debug, Default)]
pub struct SeccompPolicy {
    /// Syscalls to explicitly allow (unconditionally).
    /// These syscalls will execute normally without any filtering.
    pub allowed_syscalls: Vec<String>,

    /// Syscalls to block with a specified action.
    /// Each tuple contains the syscall name and the action to take.
    pub blocked_syscalls: Vec<(String, BlockAction)>,

    /// Action for syscalls not in allowed or blocked lists.
    /// Default is `Trap` which sends SIGSYS (debuggable but still secure).
    pub default_action: DefaultAction,
}

/// Configuration for filesystem isolation using pivot_root.
///
/// When provided, the sandboxed process will have a restricted view of the
/// filesystem, only able to access the new root and explicitly bind-mounted paths.
///
/// If not provided (None), the process has unrestricted filesystem access.
#[derive(Clone, Debug)]
pub struct PivotRootFsConfig {
    /// New root directory for the sandboxed process.
    /// This directory must exist and will become "/" for the sandboxed process.
    pub new_root: PathBuf,

    /// Bind mounts: (source, destination_within_new_root, writable).
    /// Each entry mounts `source` at `new_root/destination` with the specified
    /// write permission.
    pub bind_mounts: Vec<(PathBuf, PathBuf, bool)>,

    /// Whether to mount a tmpfs at /tmp within the sandbox.
    /// Recommended for most use cases to provide a writable temporary directory.
    pub mount_tmp: bool,

    /// Whether to remount /proc as read-only within the sandbox.
    /// Provides additional protection against proc-based attacks.
    pub remount_proc_readonly: bool,
}

/// Generates a minijail seccomp policy string from the configuration.
///
/// The policy format is minijail's seccomp filter syntax:
/// - `syscall: 1` - allow the syscall
/// - `syscall: return <errno>` - block and return errno
/// - `syscall: trap` - block and send SIGSYS
/// - `syscall: kill` - block and terminate immediately
fn generate_seccomp_policy(policy: &SeccompPolicy) -> String {
    let mut output = String::new();

    // Header comment
    output.push_str("# Seccomp policy generated by agentwire\n");
    output.push_str("# Default action: ");
    match policy.default_action {
        DefaultAction::Trap => output.push_str("trap (SIGSYS)\n"),
        DefaultAction::Kill => output.push_str("kill\n"),
    }
    output.push('\n');

    // Allowed syscalls
    if !policy.allowed_syscalls.is_empty() {
        output.push_str("# Allowed syscalls\n");
        for syscall in &policy.allowed_syscalls {
            output.push_str(&format!("{}: 1\n", syscall));
        }
        output.push('\n');
    }

    // Blocked syscalls with specific actions
    if !policy.blocked_syscalls.is_empty() {
        output.push_str("# Blocked syscalls\n");
        for (syscall, action) in &policy.blocked_syscalls {
            match action {
                BlockAction::ReturnErrno(errno) => {
                    output.push_str(&format!("{}: return {}\n", syscall, errno));
                }
                BlockAction::Trap => {
                    output.push_str(&format!("{}: trap\n", syscall));
                }
                BlockAction::Kill => {
                    output.push_str(&format!("{}: kill\n", syscall));
                }
            }
        }
    }

    output
}

/// Applies minijail configuration to the current process.
///
/// This function should be called in a `pre_exec` context (after `fork()`, before `exec()`).
/// The seccomp filter and filesystem isolation are applied to the current process.
///
/// # Arguments
///
/// * `seccomp_policy` - The seccomp policy defining allowed/blocked syscalls
/// * `pivot_root_fs_config` - Optional filesystem isolation configuration.
///   If `None`, no filesystem isolation is applied (unrestricted access).
///
/// # Errors
///
/// Returns an error if minijail setup fails. The calling code should **not** continue
/// execution if this function fails - the process should terminate.
///
/// # Safety
///
/// This function modifies the security context of the current process. It should only
/// be called once per process, typically in a `pre_exec` hook.
pub fn apply_minijail(
    seccomp_policy: &SeccompPolicy,
    pivot_root_fs_config: Option<&PivotRootFsConfig>,
) -> io::Result<()> {
    let mut jail = Minijail::new()
        .map_err(|e| io::Error::new(io::ErrorKind::Other, e.to_string()))?;

    // 1. Apply pivot_root filesystem isolation (if configured)
    if let Some(fs_config) = pivot_root_fs_config {
        jail.enter_pivot_root(&fs_config.new_root)
            .map_err(|e| io::Error::new(io::ErrorKind::Other, e.to_string()))?;

        for (src, dst, writable) in &fs_config.bind_mounts {
            jail.mount_bind(src, dst, *writable)
                .map_err(|e| io::Error::new(io::ErrorKind::Other, e.to_string()))?;
        }

        if fs_config.mount_tmp {
            jail.mount_tmp();
        }

        if fs_config.remount_proc_readonly {
            jail.remount_proc_readonly();
        }
    }

    // 2. Generate seccomp policy and write to temp file
    let policy_str = generate_seccomp_policy(seccomp_policy);

    let mut policy_file = tempfile::NamedTempFile::new()?;
    policy_file.write_all(policy_str.as_bytes())?;
    policy_file.flush()?;

    tracing::debug!(
        "Seccomp policy written to: {:?}\n{}",
        policy_file.path(),
        policy_str
    );

    // 3. Prevent privilege escalation
    jail.no_new_privs();

    // 4. Parse and apply seccomp filter
    jail.parse_seccomp_filters(policy_file.path())
        .map_err(|e| io::Error::new(io::ErrorKind::Other, e.to_string()))?;

    // 5. Set default action based on policy
    match seccomp_policy.default_action {
        DefaultAction::Trap => {
            // Trap is minijail's default behavior for use_seccomp_filter()
            jail.use_seccomp_filter();
        }
        DefaultAction::Kill => {
            // For kill mode, we use the stricter seccomp mode
            jail.use_seccomp_filter();
            // Note: minijail's default for unlisted syscalls in seccomp filter mode
            // is to kill. The trap behavior comes from log_seccomp_filter_failures()
            // which we intentionally don't call for Kill mode.
        }
    }

    tracing::info!("Minijail seccomp filter applied");

    // The jail object is dropped here, but the seccomp filter persists
    // because it's applied to the process, not the Minijail object

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_seccomp_policy_basic() {
        let policy = SeccompPolicy {
            allowed_syscalls: vec!["read".into(), "write".into(), "exit_group".into()],
            blocked_syscalls: vec![
                ("socket".into(), BlockAction::ReturnErrno(1)),
                ("connect".into(), BlockAction::Trap),
                ("bind".into(), BlockAction::Kill),
            ],
            default_action: DefaultAction::Trap,
        };

        let output = generate_seccomp_policy(&policy);

        assert!(output.contains("read: 1"));
        assert!(output.contains("write: 1"));
        assert!(output.contains("exit_group: 1"));
        assert!(output.contains("socket: return 1"));
        assert!(output.contains("connect: trap"));
        assert!(output.contains("bind: kill"));
    }

    #[test]
    fn test_generate_seccomp_policy_empty() {
        let policy = SeccompPolicy::default();
        let output = generate_seccomp_policy(&policy);

        // Should still have header
        assert!(output.contains("Seccomp policy generated by agentwire"));
        assert!(output.contains("Default action: trap"));
    }

    #[test]
    fn test_default_action_kill() {
        let policy = SeccompPolicy {
            allowed_syscalls: vec!["read".into()],
            blocked_syscalls: vec![],
            default_action: DefaultAction::Kill,
        };

        let output = generate_seccomp_policy(&policy);
        assert!(output.contains("Default action: kill"));
    }

    #[test]
    fn test_seccomp_policy_default() {
        let policy = SeccompPolicy::default();
        assert!(policy.allowed_syscalls.is_empty());
        assert!(policy.blocked_syscalls.is_empty());
        assert!(matches!(policy.default_action, DefaultAction::Trap));
    }
}
