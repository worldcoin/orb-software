<!DOCTYPE HTML>
<html lang="en" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>orb-software</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="first-time-setup.html">First Time Setup</a></li><li class="chapter-item expanded "><a href="development.html">Developing Code</a></li><li class="chapter-item expanded "><a href="open-source.html">How we do Open Source</a></li><li class="chapter-item expanded "><a href="hil/index.html">Hardware In The Loop</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hil/cli.html">Orb-HIL CLI</a></li><li class="chapter-item expanded "><a href="hil/nixos-setup.html">Setting Up NixOS</a></li><li class="chapter-item expanded "><a href="hil/hardware-setup.html">Hardware Setup</a></li></ol></li><li class="chapter-item expanded "><a href="components/index.html">Software Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="components/orb-core/index.html">Orb Core</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">orb-software</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="./orb-wireframe.png" alt="A wireframe diagram of the orb" /></p>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome! This book serves as the spot that the <a href="https://worldcoin.org">Worldcoin Project</a>
hosts its documentation for developing software for <a href="https://worldcoin.org/blog/engineering/opening-orb-look-inside-worldcoin-biometric-imaging-device">the orb</a>.</p>
<p>It also provides an inside look at our development practices, which
helps increase transparency of the project and provide foundations for other
contributors to the project to build on top of.</p>
<h2 id="who-is-this-for"><a class="header" href="#who-is-this-for">Who is this for?</a></h2>
<p>The target audience of this documentation is for contributors to the
<a href="https://github.com/worldcoin/orb-software">orb-software repo</a> or any of the other open source repos that pertain to
the orb. We plan to accept contributions at a later date, but do not have bandwidth to
review PRs currently.</p>
<p>Likewise, we are providing source code and documentation for the benefit of the community,
but cannot commit to any SemVer or API stability guarantees. Be warned: we may
change things in a backwards-incompatible way at any time!</p>
<h2 id="where-is-the-code"><a class="header" href="#where-is-the-code">Where is the code?</a></h2>
<p>See the <a href="https://github.com/worldcoin/orb-software">orb-software repo</a> for the code.</p>
<p>This is a living document. If you are a contributor and wish to improve the documentation,
simply open a PR! The source code for the mdBook lives <a href="https://github.com/worldcoin/orb-software/tree/main/docs">here</a>.</p>
<p>However, spam/noise/typo PRs will be ignored. Especially those from bots. Do not farm
green github squares from us.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initial-repo-setup"><a class="header" href="#initial-repo-setup">Initial repo setup</a></h1>
<p>To be able to build the code, there is some first-time setup required.</p>
<h2 id="set-up-nix--direnv-the-developer-environment"><a class="header" href="#set-up-nix--direnv-the-developer-environment">Set up nix + direnv (the developer environment)</a></h2>
<p>We use <a href="https://zero-to-nix.com">nix</a> to manage all of the dependencies during development.
While most of the software can use convnetional rust tools like cargo, we do
have a few additional dependencies. Instead of apt-installing them, we use nix
as the package manager, and use <a href="https://direnv.net/">direnv</a> to handle automatically
activating a developer shell. The process to install and configure these two
tools is as follows:</p>
<ol>
<li><a href="https://zero-to-nix.com/start/install">Install nix</a>. This works for both mac and linux, if you are
using a windows machine, you must first set up <a href="https://learn.microsoft.com/en-us/windows/wsl/install">WSL2</a>.</li>
<li>Ensure that you have these lines in your <code>~/.config/nix/nix.conf</code> or
<code>/etc/nix/nix.conf</code>. This is done automatically by the above installer:
<pre><code>experimental-features = nix-command flakes
max-jobs = auto
</code></pre>
You can check that things work by running <code>nix run nixpkgs#hello</code></li>
<li>Install direnv: <code>nix profile install nixpkgs#direnv</code></li>
<li><a href="https://direnv.net/docs/hook.html">Hook direnv</a> into your shell.</li>
<li>Set up your personalized .envrc file by running <code>cp .envrc.example .envrc</code>.
You can customize this file if you wish. We recommend filling in your cachix
token if you have one. If prompted, dont run <code>direnv allow</code> yet, follow step
6 first. Otherwise you'll get a bunch of errors.</li>
<li>Follow the instructions on vendoring proprietary SDKs in the subsequent
section.</li>
<li>Run <code>direnv allow</code> in the repository's root directory. Direnv will then
automatically use the .envrc file you set up any time you <code>cd</code> into the
directory.</li>
<li>If you are on macos, run the following:
<pre><code class="language-bash">brew install dbus
brew services start dbus
</code></pre>
</li>
</ol>
<h2 id="vendoring-proprietary-sdks"><a class="header" href="#vendoring-proprietary-sdks">Vendoring proprietary SDKs</a></h2>
<p>Although all of Worldcoin's code in the orb-software repo is open source, some of the
sensors on the orb rely on proprietary SDKs provided by their hardware vendors.
Luckily, these are accessible without any cost, they are just annoying to get and
are not themselves open source.</p>
<p>To get started, you will need to download these SDKs. The process for this
depends on if you are officially affiliated with Worldcoin.</p>
<h3 id="if-you-have-access-to-worldcoin-private-repos"><a class="header" href="#if-you-have-access-to-worldcoin-private-repos">If you have access to Worldcoin private repos</a></h3>
<ol>
<li>Create a <a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-fine-grained-personal-access-token">personal access token</a> from github to allow you to use
private git repos over HTTPS.</li>
<li>Append the following to your <code>~/.config/nix/nix.conf</code>:
<pre><code>access-tokens =
github.com=github_pat_YOUR_ACCESS_TOKEN_HERE
</code></pre>
</li>
<li>Test everything works so far by running <code>nix flake metadata github:worldcoin/priv-orb-core</code>. You should see a tree of info. If not, you
probably don't have your personal access token set up right - post in slack
for help.</li>
</ol>
<h3 id="if-you-dont-have-access-to-worldcoin-private-repos"><a class="header" href="#if-you-dont-have-access-to-worldcoin-private-repos">If you don't have access to Worldcoin private repos</a></h3>
<ol>
<li>Go to <a href="https://developer.thermal.com/">https://developer.thermal.com</a> and create a developer
account. Getting the SDK can take several days for Seek Thermal to approve
access. In the meantime, you can skip steps 2 and 3.</li>
<li>Download the 4.1.0.0 version of the SDK (its in the developer forums).</li>
<li>Extract its contents, and note down the dir that <em>contains</em> the
<code>Seek_Thermal_SDK_4.1.0.0</code> dir.</li>
<li>modify your <code>.envrc</code> like this: <code>use flake --override-input seekSdk "PATH_FROM_STEP_3"</code>. If you don't yet have access to the SDK, just provide
a path to an empty directory.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-develop-and-build-code"><a class="header" href="#how-to-develop-and-build-code">How to develop and build code</a></h1>
<p>Make sure you followed the <a href="./first-time-setup.html">first time setup</a> instructions.</p>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<p>We use <code>cargo zigbuild</code> for most things. The following cross-compiles a binary
in the <code>foobar</code> crate to the orb. Replace <code>foobar</code> with the crate that you wish
to build:</p>
<pre><code class="language-bash">cargo zigbuild --target aarch64-unknown-linux-gnu --release -p foobar
</code></pre>
<p>You can also build code faster with <code>cargo check</code>, since it skips the linking
step. Try running <code>cargo check -p foobar</code>.</p>
<h1 id="testing-the-code"><a class="header" href="#testing-the-code">Testing the code</a></h1>
<p>Unlike building the code, tests are expected to run on the same target as the
host. But not all tests are possible on every target.</p>
<p><em>IF</em> it is supported, you can run <code>cargo test -p foobar</code> like normal. But
support varies from crate to crate.</p>
<h2 id="running-the-code"><a class="header" href="#running-the-code">Running the code</a></h2>
<p>For binaries that are intended to run on the orb, you can take your
cross-compiled binary, and scp it onto the orb. You can either use teleport (if
you have access) via <code>tsh scp</code> or you can get the orb's ip address and directly
scp it on, with the <code>worldcoin</code> user.</p>
<p>If you choose the <code>scp</code> route without teleport, you will need to know the
password for the <code>worldcoin</code> user. Note that this password is only for dev
orbs, orbs used in prod are not accessible without teleport and logging in with
a password is disabled.</p>
<h2 id="debugging"><a class="header" href="#debugging">Debugging</a></h2>
<h3 id="tokio-console"><a class="header" href="#tokio-console">Tokio Console</a></h3>
<p>Some of the binaries have support for <a href="https://github.com/tokio-rs/console?tab=readme-ov-file#extremely-cool-and-amazing-screenshots">tokio console</a>. This is
useful when debugging async code. Arguably the most useful thing to use it for
is to see things like histograms of <code>poll()</code> latencies, which can reveal when
one is accidentally blocking in async code. Double check that the binary you
wish to debug actually supports tokio console - support has to be manually
added, it isn't magically available by default.</p>
<p>To use tokio console, you will need to scp a cross-compiled tokio-console
binary to the orb. To do this, just clone the <a href="https://github.com/tokio-rs/console?tab=readme-ov-file#extremely-cool-and-amazing-screenshots">repo</a> and use
<code>cargo zigbuild --target aarch64-unknown-linux-gnu --release --bin tokio-console</code>, then scp it over.</p>
<blockquote>
<p>Note: tokio-console supports remote debugging via grpc, but I haven't figured out
how to get the orb to allow that yet - I assume we have a firewall in place
to prevent arbitrary tcp access, even in dev orbs.</p>
</blockquote>
<p>Then, you must build the binary you want to debug unstable tokio features
enabled. To do this, uncomment the line in
<a href=".cargo/config.toml">.cargo/config.toml</a> about tokio unstable.</p>
<p>Finally, make sure that the binary has the appropriate RUST_LOG level set up.
try using <code>RUST_LOG="info,tokio=trace,runtime=trace"</code>.</p>
<p>Finally, run your compiled binary and the compiled <code>tokio-console</code> binary on
the orb. You should see a nice TUI.</p>
<p>Note that it is recommended but not required to have symbols present to improve
the readability of debugging.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-we-do-open-source"><a class="header" href="#how-we-do-open-source">How we do open source</a></h1>
<p>Worldcoin is committed to building a fully open source, decentralized
ecosystem. In service of this goal, the entirety of the orb-software repo is
open source under an MIT/Apache 2.0 dual license. You can read more about the
project's open sourcing efforts <a href="https://worldcoin.org/blog/engineering/worldcoin-foundation-open-sources-core-components-orb-software">here</a>.</p>
<p>All source code for the Worldcoin Project lives under the <a href="https://github.com/worldcoin">worldcoin github
organizaton</a>.</p>
<h2 id="overview-of-private-repos"><a class="header" href="#overview-of-private-repos">Overview of private repos</a></h2>
<p>To the maximum extent possible, we put all public code in the orb-software and
orb-firmware repos. But we also maintain private repos, which contain code that
is responsible for fraud detection or uses third party SDKs that we do not have
a license to open source.</p>
<p>The most notable private repos are:</p>
<ul>
<li><a href="https://github.com/worldcoin/priv-orb-firmware">priv-orb-firmware</a>. This repo contains the fraud
sensitive parts of the firmware. It consumes the public
<a href="https://github.com/worldcoin/orb-firmware">orb-firmware</a> repo as a dpenedency.</li>
<li><a href="https://github.com/worldcoin/orb-internal">orb-internal</a>. This repo contains the fraud sensitive parts of
the user-space software. It consumes the public <a href="https://github.com/worldcoin/orb-software">orb-software</a>
repo as a dependency.</li>
<li><a href="https://github.com/worldcoin/priv-orb-core">priv-orb-core</a>. This repo is the mainline branch of
<code>orb-core</code>. Unlike the other repos, this is a fork of its public counterpart,
<a href="https://github.com/worldcoin/orb-core">orb-core</a>. The public repo is therefore inherently less up to date
and doesn't retain git history, as its code has all fraud-related codepaths
manually deleted. One of the long-term goals is for these two repos to become
un-forked, and most code consolidated into <code>orb-software</code> so that we can
transition to developing orb-core directly in the open.</li>
<li><a href="https://github.com/worldcoin/TrustZone">trustzone</a>. This repo contains code related to the secure
operating system OP-TEE that runs alongside linux inside ARM TrustZone. We
plan to open source the OP-TEE CAs and TAs at some point in the future.-</li>
<li><a href="https://github.com/worldcoin/orb-os">orb-os</a>. This repo is where we build the operating system image that
runs on the orb. It consumes artifacts from all the other repos to assemble
one final image.</li>
<li><a href="https://github.com/worldcoin/orb-update-agent">orb-update-agent</a>. Contains code for OTAing orbs. We plan
to open source this by merging it into the <code>orb-software</code> repo.</li>
<li><a href="https://github.com/worldcoin/orb-update-verifier">orb-update-verifier</a>. Contains code used during the OTA
process to check that the update booted successfully. We plan to open source
this by merging it into the <code>orb-software</code> repo.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hardware-in-loop"><a class="header" href="#hardware-in-loop">Hardware In Loop</a></h1>
<p>Developing for the orb generally requires access to an orb. To make life easy,
as well as to enable automated tests, we use an x86 linux machine as a host, which
attaches to an orb via a number of hardware peripherals. We created the <code>orb-hil</code>
cli tool to leverage this known hardware setup to perform a number of common,
useful actions.</p>
<h2 id="getting-an-x86-linux-machine"><a class="header" href="#getting-an-x86-linux-machine">Getting an x86 Linux Machine</a></h2>
<p>Technically, any x86 linux machine will do. However, we recommend using an
ASUS/Intel NUC due to its compact form factor.</p>
<p>The Linux installation needs:</p>
<ul>
<li>Access to the various attached usb devices without sudo, i.e. udev rules configured</li>
<li>Access to serial without sudo</li>
<li>Various packages (awscli2, usbutils, etc)</li>
<li>Teleport</li>
<li>Github self-hosted runner (if using this in CI).</li>
</ul>
<p>To make this setup easy, we have a <a href="https://github.com/TheButlah/nix">nix config</a> that sets all of
this up. BUT you could use regular ubuntu, or some other linux distro instead.</p>
<p>For the NixOS approach, see the <a href="hil/./nixos-setup.html">nixos setup</a>. If you use NixOS, we
can manage all the machines in one git repo, so this is the prefrred option, even
though the initial setup is a bit more hassle (for now).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orb-hil-cli"><a class="header" href="#orb-hil-cli">orb-hil cli</a></h1>
<p>There is a CLI tool to facilitate hardware-in-loop operations. This tool lives
<a href="https://github.com/worldcoin/orb-software/tree/main/hil">in the orb-software repo</a> and releases can be downloaded
<a href="hil/hil-releases">here</a>.</p>
<p>It is a single, statically linked CLI tool with lots of features helpful for
development:</p>
<ul>
<li>Rebooting orbs into either normal or recovery mode</li>
<li>Flashing orbs (including downloading from S3, extraction, etc)</li>
<li>Executing commands over serial</li>
<li>Automating the login process over serial</li>
</ul>
<h2 id="required-peripherals"><a class="header" href="#required-peripherals">Required peripherals</a></h2>
<p>Different <code>orb-hil</code> subcommands require different hardware peripherals. We
strongly recommend at least getting an x86 linux machine and a serial adapter.
See the <a href="hil/./hardware-setup.html">hardware setup</a> page for more detailed info.</p>
<p>Here are the different hardware peripherals necessary for the different
subcommands of <code>orb-hil</code>:</p>
<ul>
<li><code>orb-hil flash</code>: x86 linux machine</li>
<li><code>orb-hil reboot</code>: Serial adapter.</li>
<li><code>orb-hil login</code>: Serial adapter.</li>
<li><code>orb-hil cmd</code>: Serial adapter.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hil-nixos-setup"><a class="header" href="#hil-nixos-setup">HIL NixOS Setup</a></h1>
<p>Eventually, we will support making installation media from the NixOS config
directly, including setup scripts to fully automate this process. But <em>for now</em>,
one first needs to do a lot of manual bootstrapping.</p>
<h3 id="installing-nixos-to-a-liveusb"><a class="header" href="#installing-nixos-to-a-liveusb">Installing NixOS to a liveusb</a></h3>
<p>On the ASUS NUCs, they don't support MBR partitioned live usbs. But for some
inexplicable reason the official NixOS installer <em>only</em> exists as a MBR partitioned
disk. This means we need to build our own GPT/UEFI based NixOS live usb ;(</p>
<p>TODO: Describe how to make a UEFI-compatible minimal nixos live usb. The TLDR
is that you use <a href="https://github.com/nix-community/nixos-generators">nixos-generators</a> with the <code>raw-efi</code> format.</p>
<h3 id="use-the-liveusb-to-install-nixos"><a class="header" href="#use-the-liveusb-to-install-nixos">Use the liveusb to install NixOS</a></h3>
<h4 id="booting-from-the-liveusb"><a class="header" href="#booting-from-the-liveusb">Booting from the liveusb</a></h4>
<p>This is the same as any other linux liveusb. Get into your boot menu using the
function keys at boot, and select the USB from the boot options. If it doesn't
show up, make sure you are using a GPT/UEFI based liveusb. You will likely need
to disable UEFI secure boot as well.</p>
<h4 id="setting-up-partitions"><a class="header" href="#setting-up-partitions">Setting up Partitions</a></h4>
<p>You need three partitions:</p>
<ul>
<li>EFI (512MB, format as FAT32)</li>
<li>Swap (Make it 32GB or size of ram, whichever is bigger. Format as linux-swap)</li>
<li>Rootfs (Rest of disk, format as ext4)</li>
</ul>
<p>TODO: Describe how to do this from <code>parted</code>. See also <a href="https://nixos.wiki/wiki/NixOS_Installation_Guide#UEFI">here</a> and <a href="https://github.com/SfikasTeo/NixOS?tab=readme-ov-file#configuring-partitions-and-filesystems">here</a></p>
<p>After you finish this step, the rootfs partition should be mounted to to /mnt and the EFI boot partition to /mnt/boot.</p>
<h4 id="install-nixos-from-the-liveusb"><a class="header" href="#install-nixos-from-the-liveusb">Install NixOS from the liveusb</a></h4>
<ol>
<li>
<p>Make sure that the new partitions are mounted under <code>/mnt</code> and <code>/mnt/boot</code>.</p>
</li>
<li>
<p>Run <code>sudo nixos-generate-config --root /mnt</code>. This will create a new nixos
config for the NUC.</p>
</li>
<li>
<p>Edit the NUC's NixOS config at <code>/mnt/etc/nixos/configuration.nix</code> to be the
following: TODO: Make sure this is all that is needed, and just use this to
generate an image instead of them typing it in.</p>
<p><code>/mnt/etc/nixos/configuration.nix</code>:</p>
<pre><code class="language-nix">{ config, pkgs, lib, ... }:
let
  username = "worldcoin";
  hostname = "my-hostname-here";
  hashedPassword = ""; # paste output of mkpasswd here
in
{
  networking.hostName = "${hostname}";
  
  environment.systemPackages = with pkgs; [
    curl
    git
    neovim
    parted
    usbutils
    vim
  ];

  # Enable the OpenSSH daemon.
  services.openssh = {
    enable = true;
    passwordAuthentication = false;
  };

  # Enable the X11 windowing system.
  services.xserver.enable = true;
  # Enable the KDE Plasma Desktop Environment.
  services.xserver.displayManager.sddm.enable = true;
  services.xserver.desktopManager.plasma5.enable = true;

  # Enable networking
  networking.networkmanager.enable = true;

  users.users."${username}" = {
    isNormalUser = true;
    description = "${username}";
    hashedPassword = hashedPassword;
    extraGroups = [
      "networkmanager"
      "wheel" # Gives sudo
      "plugdev"
      "dialout"
    ];
  };

  # use the latest Linux kernel
  boot = {
    kernelPackages = pkgs.linuxPackages_latest;
    # Needed for https://github.com/NixOS/nixpkgs/issues/58959
    supportedFilesystems = lib.mkForce [ "btrfs" "reiserfs" "vfat" "f2fs" "xfs" "ntfs" "cifs" ];
  };
}
</code></pre>
</li>
<li>
<p>Make sure that your liveusb is connected to the internet. If its not, you
can use <code>nmtui</code> to connect.</p>
</li>
<li>
<p><code>cd /mnt &amp;&amp; sudo nixos-install</code></p>
</li>
<li>
<p><code>sudo shutdown -h now</code>, and remove the liveusb.</p>
</li>
<li>
<p>Boot the freshly installed NixOS (you may need to select it from the boot menu).</p>
</li>
<li>
<p>Make sure that all of the following is true:</p>
</li>
</ol>
<ul>
<li>You can boot into it.</li>
<li>You have internet access (you can connect to wifi with <code>nmtui</code>).</li>
<li>You have sudo rights</li>
</ul>
<h4 id="switch-to-the-full-nixos-config"><a class="header" href="#switch-to-the-full-nixos-config">Switch to the full NixOS config.</a></h4>
<p>Now that NixOS is installed on the NUC, we need to upgrade it to the full blown
config that we use. Luckily nix makes this really easy.</p>
<ol>
<li>Clone the <a href="https://github.com/TheButlah/nix">nix config</a>.</li>
<li>Customize the config to add an entry for your new machine. Be sure you set the
hostname to be the same as what the current hostname is. You can ask @thebutlah
to do this for you or look at the existing config to figure it out. Eventually we
will make this really easy. Be sure that you add a ssh key for your account so that
you can still access it in the case that teleport doesn't work.</li>
<li>(only if creating a self-hosted runner) Create a
<code>/etc/worldcoin/secrets/gh-runner-token</code> file and populate it with the
<code>orb-os-self-hosted-runner</code> token from 1Password.</li>
<li>Clone the <a href="https://github.com/TheButlah/nix">nix config</a> to ~/nix.</li>
<li>Run <code>sudo nixos-rebuild --impure --flake ~/nix</code></li>
<li>Install teleport. Ask in slack for how to do this, its a bit involved, since
it requires manually editing the shell script, as well as requesting access.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hardware-setup"><a class="header" href="#hardware-setup">Hardware Setup</a></h1>
<p>The HIL leverages the use of several hardware peripherals to control the orb.
Most important is the serial adapter and the x86 linux machine. While any x86
linux machine will do, we recommend purchasing an ASUS/Intel NUC due to the
convenient form factor.</p>
<h2 id="required-parts"><a class="header" href="#required-parts">Required Parts</a></h2>
<p>We break down the parts into common/shared items, and items per-hil.</p>
<blockquote>
<p>Note: Not all of these parts are required. In the most minimal case, we
recommend at least getting some electrical tape, an x86 linux machine, the
Micro USB cable, and a serial adapter. This will cover 90% of the use cases.
Note also, no soldering is required!</p>
</blockquote>
<h3 id="shared"><a class="header" href="#shared">Shared</a></h3>
<ul>
<li>Electrical Tape
<ul>
<li>US Source: TODO</li>
<li><a href="https://www.amazon.de/-/en/dp/B00PYFI1UW">DE Source</a></li>
</ul>
</li>
<li>Some Male-Male Jumper Wires (but Male-Female or Female-Female as needed).
<ul>
<li>US Source: TODO</li>
<li><a href="https://www.amazon.de/-/en/dp/B0D2XVMTFX">DE Source</a></li>
</ul>
</li>
<li>Display for initial bringup
<ul>
<li>Any monitor + keyboard + mouse, or:</li>
<li><a href="https://www.amazon.com/dp/B07VNX4ZWY">US Source</a></li>
<li><a href="https://www.amazon.de/-/en/dp/B0B8S9DYQC">DE Source</a></li>
</ul>
</li>
<li>A flash-drive</li>
</ul>
<h3 id="per-hil-rig"><a class="header" href="#per-hil-rig">Per HIL Rig</a></h3>
<h4 id="the-essentials"><a class="header" href="#the-essentials">The Essentials</a></h4>
<ul>
<li>1x Intel NUC 13 Pro Mini PC Core i7-1360P 16GB RAM
<ul>
<li><a href="https://www.amazon.com/dp/B0CYBMSJ2K">US source</a></li>
<li><a href="https://www.amazon.de/-/en/dp/B0CB1DY5KJ">DE Source</a></li>
</ul>
</li>
<li>1x FT232(RL) Serial Adapter
<ul>
<li><a href="https://www.amazon.com/dp/B07BBPX8B8">US Source</a></li>
<li><a href="https://www.amazon.de/-/en/dp/B07TXVRQ7V">DE Source</a></li>
</ul>
</li>
<li>1x USB Power Blocker for Flashing Cable
<ul>
<li><a href="https://www.amazon.com/dp/B094G4P3P4">US Source</a></li>
<li><a href="https://www.amazon.de/-/en/dp/B094FYL9QT">DE Source</a></li>
</ul>
</li>
<li>USB A male to micro USB male cable
<ul>
<li>US Source: TODO</li>
<li><a href="https://www.amazon.de/-/en/dp/B08HSBZW75">DE Source</a></li>
</ul>
</li>
<li>USB Dock (at least three usb-A ports)</li>
</ul>
<h4 id="flashing-the-microcontrollers"><a class="header" href="#flashing-the-microcontrollers">Flashing the microcontrollers</a></h4>
<ul>
<li>2x st-link v3
<ul>
<li><a href="https://www.amazon.com/dp/B07ML6F12Y">US Source</a></li>
<li><a href="https://www.amazon.de/-/en/dp/B07M6YJ7X5">DE Source</a></li>
</ul>
</li>
<li>2x tag-connect jtag adapter
<ul>
<li><a href="https://www.tag-connect.com/product/tc2030-ctx-6-pin-cable-for-arm-cortex">US Source</a></li>
<li><a href="https://www.tag-connect.com/product/tc2030-ctx-6-pin-cable-for-arm-cortex">DE Source</a></li>
</ul>
</li>
</ul>
<h2 id="connecting-the-parts-to-the-orb"><a class="header" href="#connecting-the-parts-to-the-orb">Connecting the parts to the orb</a></h2>
<h3 id="flashing-support"><a class="header" href="#flashing-support">Flashing support</a></h3>
<ol>
<li>Connect the microusb cable to the microusb port of the orb.</li>
<li>Use the USB Power blocker to ensure that this cable is data-only. This will
ensure that the main mcu doesn't get power from the cable. This is an
optional but highly recommended step.</li>
<li>Connect the usb power blocker to the NUC directly. Do not use the usb dock.</li>
</ol>
<h3 id="serial-and-reboot-support"><a class="header" href="#serial-and-reboot-support">Serial and Reboot support</a></h3>
<ol>
<li>Ensure the serial adapter is configured for 3.3v. There is a jumper on the
serial adapter that controls this setting.</li>
<li>Add electrical tape behind the TX and RX pins, to prevent short circuiting
the pins against the chassy.</li>
<li>Connect the GND pin of the serial adapter to the GND pin on the orb (there
is one at the top).</li>
<li>Connect TX and RX pins to the orb. TX (blue) on bottom, RX (green) on top.
<img src="hil/../serial-pins.png" alt="picture of serial pins" /></li>
<li>Connect CTS pin to the BTN pin. Its located below the top
GND pin. This allows controlling the power button of the orb.
<img src="hil/../button-pin.png" alt="picture of CTS pin" /></li>
<li>Connect the RTS pin to the bottom of the two pins on the recovery mode
jumper on the right side of the orb. This allows controlling recovery mode
of the orb.
<img src="hil/../recovery-pin.png" alt="picture of recovery" /></li>
<li>Double check that nothing is going to short circuit. It is ok for the GND
pin to touch the chassy, but it is NOT ok for any of the other pins to touch
anything else.</li>
<li>Plug the serial adapter into the USB dock and connect the dock to the NUC.</li>
</ol>
<h3 id="optional-recovery-from-a-bricked-microcontroller"><a class="header" href="#optional-recovery-from-a-bricked-microcontroller">(Optional) Recovery from a bricked microcontroller</a></h3>
<p>For each microcontroller that you want to be able to recover without, you
should attach the ST-Link. For setups where you don't want to physically have
to access the orb, we recommend keeping both ST-Links always attached to their
microcontrollers. You can do this by:</p>
<ol>
<li>Plug the tag-connect adapter into the port. There are two - one for the main
mcu on the front center of the orb, and one for the security mcu on the back
of the orb.</li>
<li>Connect the other end of the tag-connect to the ST-Link.</li>
<li>Plug the st-link into the NUC (via the dock or directly).</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-components-of-the-orb"><a class="header" href="#software-components-of-the-orb">Software components of the orb</a></h1>
<p>The orb consists of several software components. This section of the book
provides a place to describe all of these different components.</p>
<p>See the individual sections in the table of contents to read more.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orb-core"><a class="header" href="#orb-core">Orb Core</a></h1>
<p><code>orb-core</code> contains the core rust application responsible for verifying users'
World IDs.</p>
<p>The binaries controlling the orb are found in src/bin/:</p>
<pre><code>src/bin/orb-core.rs: the production binary, which runs verifications in the field;
src/bin/orb-backend-connect.rs: a binary to ensure backend connectivity by scanning a WiFi QR code and establishing the WiFi connection as long as the backend is not reachable
</code></pre>
<h2 id="code-overview"><a class="header" href="#code-overview">Code Overview</a></h2>
<iframe width="560" height="315"
    src="https://www.youtube.com/embed/h6AjLyj6ics?si=Z2zlweF1nW03qHFb"
    title="YouTube video player" frameborder="0" allow="accelerometer;
    autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture;
    web-share" referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen></iframe>
<pre class="mermaid">flowchart TD
    A[Start Signup] --&gt; B{Scan Operator QR Code}
    B --&gt;|Success| C{Scan User QR Code}
    B --&gt;|Failure| Z[End Signup]
    C --&gt;|Success| D{Detect Face}
    C --&gt;|Failure| Z
    D --&gt;|Detected| E[Start Image Notary]
    D --&gt;|Not Detected| Z
    E --&gt; F[Biometric Capture]
    F --&gt; G[Stop Image Notary]
    G --&gt; H[Biometric Pipeline]
    H --&gt; I{Detect Fraud}
    I --&gt;|No Fraud| J[Enroll User]
    I --&gt;|Fraud Detected| K[Mark as Fraud]
    J --&gt;|Success| L[Mark Signup as Successful]
    J --&gt;|Failure| M[Mark Signup as Failed]
    K --&gt; N[Upload Debug Report and Opt-in Images]
    L --&gt; N
    M --&gt; N
    N --&gt; Z
</pre>
<h2 id="state-of-open-sourcing"><a class="header" href="#state-of-open-sourcing">State of open sourcing</a></h2>
<p>There are <em>two</em> orb-cores: the public one at <a href="https://github.com/worldcoin/orb-core">worldcoin/orb-core</a> and
the private one at <a href="https://github.com/worldcoin/priv-orb-core">worldcoin/priv-orb-core</a>. Today, the public repo
is a manually stripped down version of the private one. This is done to remove
code paths that could reveal the types of fraud detection that we perform. Long
term, we plan to un-fork these two repos such that the public code lives in
<a href="https://github.com/worldcoin/orb-software">worldcoin/orb-software</a> and the private code is only minimal
additional code, which consumes the public code as a dependency. This will
ensure that most code we develop is done directly in the open, where <code>main</code>
lives in a public repo.</p>
<p>See <a href="components/orb-core/../../open-source.html">how we do open source</a> for more context.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
